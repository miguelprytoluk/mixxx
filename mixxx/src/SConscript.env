#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys, os, platform
import SCons.Script

#Import('platform')
#Import('machine')	#CPU architecture for optimization
#Import('architecture')	#CPU type & binary format for optimization
#Import('bitwidth')      #CPU bit width that can be forced (use this for most build items)

def determinePlatform():
	if os.name == 'nt':
		print 'Platform: Windows ' #+ machine + ' (' + architecture[0] + ')'
		platformString = 'windows'
	elif sys.platform == 'linux2':
		 print 'Platform: Linux '
		 platformString = 'linux'
	elif 'bsd' in sys.platform: #should cover {Net,Open,Free,DragonFly}BSD, but I'll be upfront: I've only built Mixxx on OpenBSD
		 print 'Platform: BSD '
		 platformString = 'bsd'
	elif sys.platform == 'darwin':
		 print 'Platform: OS X '
		 platformString = 'osx'
	else:
		print 'Platform: Unknown (assuming Linux-like,) ' + machine
		platformString = 'linux'

	Export('platformString')
	return platformString

def determineArchitecture(platformString):
	architecture = platform.architecture()
	machine = platform.machine()
	bitwidth = architecture[0][0:2];	# "32" or "64"

	Export('architecture')
	Export('machine')	#So architecture-specific decisions & optimizations can be made in the SConscript
	Export('bitwidth')

	# Allow to override auto-detection (environment variables must already be set appropriately with SETENV.CMD /xp /x86 or /x64)
	# (Auto-detection of 64-bit only works correctly if you're running a 64-bit version of Python, otherwise it'll see an x86 system)
	flags_force32 = ARGUMENTS.get('force32', 0)
	flags_force64 = ARGUMENTS.get('force64', 0)
	if int(flags_force32) and not int(flags_force64):
		if 'win' in platformString:
			machine = 'x86'
		else:
			env.Append(CCFLAGS = '-m32')
			env.Append(CXXFLAGS = '-m32')
			env.Append(LINKFLAGS = '-m32')
		bitwidth = '32'
		print 'FORCING ' +bitwidth+ '-BIT BUILD: ' + platformString + ' ' + machine + ' (' + bitwidth + 'bit)'

	#force 64-bit compile
	if int(flags_force64) and not int(flags_force32):
		if 'win' in platformString:
			machine = 'AMD64'
		else:
			env.Append(CCFLAGS = '-m64')
			env.Append(CXXFLAGS = '-m64')
			env.Append(LINKFLAGS = '-m64')
		bitwidth = '64'
		print 'FORCING ' +bitwidth+ '-BIT BUILD: ' + platformString + ' ' + machine + ' (' + bitwidth + 'bit)'

	print 'Binary format: ' + architecture[1]

	return {"machine":machine, "bitwidth":bitwidth}

def getBuildDir(platformString, bitwidth):
	build_dir = '%s%s_build' % (platformString[0:3],bitwidth)
	Export('build_dir')
	return build_dir

def getSVNRevision(): # GPL code taken from http://trac.zeitherrschaft.org/zzub/browser/trunk/SConstruct
	# if this is a repository, take the string from svnversion
	svnversionpath = env.WhereIs('svnversion', os.environ['PATH'])
	if os.path.isdir('../.svn') and (svnversionpath != None):  # we always start in .obj for some reason, so we must use ../.svn
		rev = os.popen('svnversion ..').readline().strip()
		if rev != "" and rev != "exported":
			return rev
	return ""

def getBZRRevision():
	return os.popen("bzr revno").readline().strip()

def getMixxxVersion():
	defs = File('#src/defs_version.h') #have to handle out-of-tree building, that's why the '#' :(
	#p = os.popen('grep -m 1 "#define VERSION" %s' % defs) #this is not cross-platform
	#version = p.readline()
	#p.close()

	for line in open(str(defs)).readlines():
		if line.strip().startswith("#define VERSION"):
			version = line
			break
	else:
		raise ValueError("Version not found")

	#given "#define VERSION "...."" extract "....":
	version = version.split()[-1].replace('"', '')
	return version

#Check for FFMPEG support
def CheckFFMPEG(conf, sources):
	flags['ffmpeg'] = ARGUMENTS.get('ffmpeg', 0)
	if int(flags['ffmpeg']):
		if platform == 'linux' or 'osx':
			#Check for libavcodec, libavformat
			#I just randomly picked version numbers lower than mine for this - Albert
			if not conf.CheckForPKG('libavcodec', '51.20.0'):
				print 'libavcodec not found.'
				Exit(1)
			if not conf.CheckForPKG('libavformat', '51.1.0'):
				print 'libavcodec not found.'
				Exit(1)
			else:
				#Grabs the libs and cflags for ffmpeg
				env.ParseConfig('pkg-config libavcodec --silence-errors --cflags --libs')
				env.ParseConfig('pkg-config libavformat --silence-errors --cflags --libs')
				env.Append(CPPDEFINES = '__FFMPEGFILE__')
		else:
			# aptitude install libavcodec-dev libavformat-dev liba52-0.7.4-dev libdts-dev
			env.Append(LIBS = 'avcodec')
			env.Append(LIBS = 'avformat')
			env.Append(LIBS = 'z')
			env.Append(LIBS = 'a52')
			env.Append(LIBS = 'dts')
			env.Append(LIBS = 'gsm')
			env.Append(LIBS = 'dc1394_control')
			env.Append(LIBS = 'dl')
			env.Append(LIBS = 'vorbisenc')
			env.Append(LIBS = 'raw1394')
			env.Append(LIBS = 'avutil')
			env.Append(LIBS = 'vorbis')
			env.Append(LIBS = 'm')
			env.Append(LIBS = 'ogg')
			env.Append(CPPDEFINES = '__FFMPEGFILE__')
		sources += Split("""soundsourceffmpeg.cpp """)
		print "Not working FFMPEG support... enabled"
	else:
		print "Not working FFMPEG support... disabled"
	return


# Checks for pkg-config on Linux
def CheckForPKGConfig( context, version='0.0.0' ):
	context.Message( "Checking for pkg-config (at least version %s)... " % version )
	ret = context.TryAction( "pkg-config --atleast-pkgconfig-version=%s" %version )[0]
	context.Result( ret )
	return ret

# Uses pkg-config to check for a minimum version
def CheckForPKG( context, name, version="" ):
	if version == "":
		context.Message( "Checking for %s... \t" % name )
		ret = context.TryAction( "pkg-config --exists '%s'" % name )[0]
	else:
		context.Message( "Checking for %s (%s or higher)... \t" % (name,version) )
		ret = context.TryAction( "pkg-config --atleast-version=%s '%s'" % (version,name) )[0]
		context.Result( ret )
	return ret

def getFlags(env, argflag, default=0):
	"""
	* get value passed as an argument to scons as argflag=value
	* if no value is passed to scons use stored value
	* if no value is stored, use default
	Returns the value and stores it in env[argflag]
	"""
	flags = ARGUMENTS.get(argflag, -1)
	if int(flags) < 0:
		if env.has_key(argflag):
			flags = env[argflag]
		else: #default value
			flags = default
	env[argflag] = flags
	return flags


flags = {}

#Determine our platform
platformString = determinePlatform()

#Figure out what the QT path is

default_qtdir = {'linux': '/usr/share/qt4',
		 'bsd': '/usr/local/lib/qt4',
		 'osx': '/usr/lib/Qt-4.5', #XXX this should be smarter, we just need qt4 so we should accept the highest version that matches /usr/lib/Qt-4.*.*/
		 'windows': 'C:\\qt\\4.5.1'}[platformString]	 #ditto

#Read the qtdir flag, if it was set explicitly
flags['qtdir'] = ARGUMENTS.get('qtdir', os.environ.get('QTDIR', default_qtdir)) #environ['QTDIR'] there is mainly for the benefit of MSVC
if not os.path.exists(flags['qtdir']):
	print "Error: QT path does not exist or QT4 is not installed."
	print "Please specify your QT path by running 'scons qtdir=[path]'"
	Exit(1)
elif flags['qtdir'].find("qt3") != -1 or flags['qtdir'].find("qt/3") != -1:
	print "Error: Mixxx now requires QT4 instead of QT3 - please use your QT4 path with the qtdir build flag."
	Exit(1)
else:
	print "QT path: " + flags['qtdir']



#Set up our environment, tell SCONS to use its QT tools, and set some enviroment variables for it.
#The ENV = os.environ part pulls in your existing environment variables. This is useful for awkward Linux setups
#and on Windows where all the paths are set in the shell.
if platformString in ('linux', 'bsd'):
	env = Environment(tools=['default','qt4'], toolpath=['#build/'], QTDIR=flags['qtdir'], ENV = os.environ)
	#Whoever hacked this in, it breaks scons for people who've set PKG_CONFIG_PATH in their shell. - Albert
 	#os.environ['PKG_CONFIG_PATH']=flags['qtdir']+'lib/pkgconfig'  #Set the PKG_CONFIG_PATH explicitly, handles multiple QT 4.x installations
elif platformString == 'osx':
	env = Environment(tools=['default', 'qt4', 'OSConsX'], toolpath=['#build/', '#/build/osx/'], ENV = os.environ)
elif 'win' in platformString:
	#Pull in the environment's variables for windows...
	env = Environment(tools=['default','qt4', 'msvs'], toolpath=['#build/'], QTDIR=flags['qtdir'], QT_LIB='', VCINSTALLDIR = os.getenv('VCInstallDir'), ENV = os.environ)
else:
	raise Exception("Unknown platform, didn't make a env variable. Crashing")

env['MIXXX_VERSION'] = getMixxxVersion() #should this be in the env?
env['CPPDEFINES'] = [''] #Initialize this as a list, fixes a bug where first CPPDEFINE would get mangled

#Figure out what architecture we are, set up bitwith and platform variables
arch_stuff = determineArchitecture(platformString)
machine = arch_stuff["machine"]
bitwidth = arch_stuff["bitwidth"]
build_dir = getBuildDir(platformString, bitwidth)

## Global cache directory
## Put all project files in it so a rm -rf cache will clean up the config
if not env.has_key('CACHEDIR'):
	env['CACHEDIR'] = str(Dir('#cache/'))
if not os.path.isdir(env['CACHEDIR']):
	os.mkdir(env['CACHEDIR'])

## Avoid spreading .sconsign files everywhere
#env.SConsignFile(env['CACHEDIR']+'/scons_signatures')
## WARNING - We found that the above line causes SCons to randomly not find
##           dependencies for some reason. It might not happen right away, but
##           a good number of users found that it caused weird problems - Albert (May 15/08)


#Hijack scons -h and --help
cachefile = str(env['CACHEDIR']) + 'custom.py'
#opts = Options(cachefile)
vars = Variables(cachefile)
vars.Add('prefix', 'Set to your install prefix', '/usr/local')
vars.Add('qtdir', 'Set to your QT4 directory', '/usr/share/qt4')
vars.Add('hifieq', 'Set to 1 to enable high quality EQs', 1)
vars.Add('ipod', 'Set to 1 to enable iPod support through libgpod', 0)
vars.Add('ladspa', '(EXPERIMENTAL) Set to 1 to enable LADSPA plugin support', 0)
vars.Add('ffmpeg', '(EXPERIMENTAL) Set to 1 to enable FFMPEG support', 0)
vars.Add('vinylcontrol', 'Set to 1 to enable vinyl control support', 1)
vars.Add('shoutcast', 'Set to 1 to enable shoutcast support', 0)
vars.Add('cmetrics', 'Set to 1 to enable crash reporting/usage statistics via Case Metrics (This should be disabled on development builds)', 0)
vars.Add('asmlib','Set to 1 to enable linking against Agner Fog\'s hand-optimized asmlib, found at http://www.agner.org/optimize/', 0)
vars.Add('script', 'Set to 1 to enable MixxxScript/QtScript Studio support.', 0)
vars.Add('midiscript', 'Set to 1 to enable MIDI Scripting support.', 1)
vars.Add('tonal', 'Set to 1 to enable tonal analysis', 0)
vars.Add('qdebug', 'Set to 1 to enable verbose console debug output.', 1)
vars.Add('test', 'Set to 1 to build Mixxx test fixtures.', 0)
if not 'win' in platformString:
	vars.Add('tuned', 'Set to 1 to optimize mixxx for this CPU (overrides "optimize")', 0)
	vars.Add('optimize', 'Set to:\n  1 for -O3 compiler optimizations\n  2 for Pentium 4 optimizations\n  3 for Intel Core optimizations\n  4 for Intel Core 2 optimizations\n  5 for Athlon-4/XP/MP optimizations\n  6 for K8/Opteron/AMD64 optimizations\n  7 for K8/Opteron/AMD64 w/ SSE3\n  8 for Celeron D (generic SSE/SSE2/SSE3) optimizations.', 1)
	vars.Add('profiling', '(DEVELOPER) Set to 1 to enable profiling using gprof (Linux) or Saturn (OS X)', 0)
else:
	if bitwidth == '64':
		vars.Add('tuned', 'Set to 1 to optimize mixxx for this CPU class', 0)
	vars.Add('optimize', 'Set to:\n  1 to maximize speed (/O2)\n  2 for maximum optimizations (/Ox)', 1)
	vars.Add('msvshacks', 'Set to 1 to build properly with MS Visual Studio 2005 (Express users should leave this off)', 0)
	vars.Add('msvcdebug', 'Set to 1 to link against MS libraries with debugging info (implies debug=1)', 0)
#env = Environment(options = opts)
vars.Update(env)
Help(vars.GenerateHelpText(env))

for getenv in ['CXXFLAGS', 'CCFLAGS', 'LINKFLAGS', 'LIBPATH', 'CPPPATH']:
	kwargs = {}
	if os.environ.has_key(getenv):
		kwargs[getenv] = SCons.Util.CLVar( os.environ[getenv] )
		env.Append(**kwargs)

#env.Append(CPPDEFINES=[('BUILD_REV', '"%s"' % getBZRRevision())]) #doing this forces a rebuild of everything whenever a commit happens -- not much fun
## instead, embed BZR version into build
## Put version info into a file, so it doesn't force a rebuild of everything :)
f = open("build.h","w")
try:
	f.write('#define BUILD_REV "' + getBZRRevision() + '"\n')
finally:
	f.close()

### embed SVN version into build
### Put version info into a file, so it doesn't force a rebuild of everything :)
#f = open("#.mixxx_version.h","w")
#try:
#	f.write('#define BUILD_REV "' + getSVNRevision() + '"\n')
#finally:
#	f.close()

#Mixxx sources to build
sources = Split("""

                input.cpp
                mixxxkeyboard.cpp
                configobject.cpp
                controlobjectthread.cpp
                controlobjectthreadwidget.cpp
                controlobjectthreadmain.cpp
                controlevent.cpp
                controllogpotmeter.cpp
                controlobject.cpp
                controlnull.cpp
                controlpotmeter.cpp
                controlpushbutton.cpp
                controlttrotary.cpp
                controlbeat.cpp

                dlgpreferences.cpp
                dlgprefsound.cpp
                dlgprefsounditem.cpp
                dlgprefmidibindings.cpp
                dlgprefplaylist.cpp
                dlgprefnomidi.cpp
                dlgprefcontrols.cpp
                dlgprefbpm.cpp
                dlgbpmscheme.cpp
                dlgabout.cpp
                dlgprefeq.cpp
                dlgprefcrossfader.cpp
                dlgmidilearning.cpp
                dlgtrackinfo.cpp
                dlgprepare.cpp
                dlgautodj.cpp

                engine/engineworker.cpp
                engine/engineworkerscheduler.cpp
                engine/enginebuffer.cpp
                engine/enginebufferscale.cpp
		engine/enginebufferscaledummy.cpp
                engine/enginebufferscalelinear.cpp
		engine/enginebufferscalereal.cpp
                engine/engineclipping.cpp
                engine/enginefilterblock.cpp
                engine/enginefilteriir.cpp
                engine/enginefilter.cpp
                engine/engineobject.cpp
                engine/enginepregain.cpp
                engine/enginevolume.cpp
                engine/enginechannel.cpp
                engine/enginemaster.cpp
                engine/enginedelay.cpp
                engine/engineflanger.cpp
                engine/enginespectralfwd.cpp
                engine/enginevumeter.cpp
                engine/enginevinylsoundemu.cpp
                engine/enginesidechain.cpp
                engine/enginefilterbutterworth8.cpp
                engine/enginexfader.cpp
                engine/enginecontrol.cpp
                engine/ratecontrol.cpp
                engine/loopingcontrol.cpp
                engine/bpmcontrol.cpp
                engine/cuecontrol.cpp
                engine/readaheadmanager.cpp
                cachingreader.cpp

                analyserqueue.cpp
		analyserwavesummary.cpp
		analyserbpm.cpp
		analyserwaveform.cpp

                midi/midimapping.cpp
                midi/midiinputmappingtablemodel.cpp
                midi/midioutputmappingtablemodel.cpp
                midi/midichanneldelegate.cpp
                midi/midistatusdelegate.cpp
                midi/midinodelegate.cpp
                midi/midioptiondelegate.cpp
                midi/midimessage.cpp
                midi/midiledhandler.cpp

                main.cpp
                controlgroupdelegate.cpp
                controlvaluedelegate.cpp
                mixxxcontrol.cpp
                mixxx.cpp
                mixxxview.cpp
                errordialoghandler.cpp
                upgrade.cpp

                soundsource.cpp
                soundsourcemp3.cpp
                soundsourceoggvorbis.cpp

                widget/wwidget.cpp
                widget/wlabel.cpp
                widget/wnumber.cpp
                widget/wnumberpos.cpp
                widget/wnumberrate.cpp
                widget/wnumberbpm.cpp
                widget/wknob.cpp
                widget/wdisplay.cpp
                widget/wvumeter.cpp
                widget/wpushbutton.cpp
                widget/wslidercomposed.cpp
                widget/wslider.cpp
                widget/wstatuslight.cpp
		widget/woverview.cpp
		widget/wskincolor.cpp
		widget/wabstractcontrol.cpp
                widget/wsearchlineedit.cpp
		widget/wpixmapstore.cpp
				widget/hexspinbox.cpp

                sampleutil.cpp
                mathstuff.cpp
                rtthread.cpp
                windowkaiser.cpp
                probabilityvector.cpp

                peaklist.cpp
                rotary.cpp
                wtracktableview.cpp
                widget/wtracktableviewheader.cpp
                widget/wlibrarysidebar.cpp
                widget/wlibrary.cpp
                widget/wlibrarytableview.cpp
                widget/wpreparelibrarytableview.cpp
                widget/wpreparecratestableview.cpp
                widget/wbrowsetableview.cpp
                widget/wlibrarytextbrowser.cpp
                library/preparecratedelegate.cpp
                library/trackcollection.cpp
                library/basesqltablemodel.cpp
                library/librarytablemodel.cpp
                library/preparelibrarytablemodel.cpp
                library/browsetablemodel.cpp
                library/missingtablemodel.cpp
                library/proxytrackmodel.cpp
                library/abstractxmltrackmodel.cpp
                library/rhythmboxtrackmodel.cpp
                library/rhythmboxplaylistmodel.cpp
                library/itunestrackmodel.cpp
                library/itunesplaylistmodel.cpp
                library/playlisttablemodel.cpp
                library/libraryfeature.cpp
                library/preparefeature.cpp
                library/autodjfeature.cpp
                library/mixxxlibraryfeature.cpp
                library/playlistfeature.cpp
                library/rhythmboxfeature.cpp
                library/itunesfeature.cpp
                library/browsefeature.cpp
                library/cratefeature.cpp
                library/browsefilter.cpp
                library/sidebarmodel.cpp
                library/libraryscanner.cpp
                library/libraryscannerdlg.cpp
                library/legacylibraryimporter.cpp
                library/library.cpp
                library/searchthread.cpp
                library/dao/cratedao.cpp
                library/cratetablemodel.cpp
                library/dao/cuedao.cpp
                library/dao/cue.cpp
                library/dao/trackdao.cpp
                library/dao/playlistdao.cpp
                library/dao/libraryhashdao.cpp
                library/dao/settingsdao.cpp
                library/librarymidicontrol.cpp
                library/schemamanager.cpp
                library/promotracksfeature.cpp
                library/featuredartistswebview.cpp
                library/bundledsongswebview.cpp
                library/songdownloader.cpp

                xmlparse.cpp
                parser.cpp
                parserpls.cpp
                parserm3u.cpp

                bpm/bpmscheme.cpp

                soundsourceproxy.cpp

                widget/wvisualsimple.cpp
                widget/wwaveformviewer.cpp
                widget/wglwaveformviewer.cpp
                waveformviewerfactory.cpp
                waveform/renderobject.cpp
                waveform/waveformrenderer.cpp
		waveform/waveformrenderbackground.cpp
		waveform/waveformrendersignal.cpp
                waveform/waveformrendersignaltiles.cpp
		waveform/waveformrendersignalpixmap.cpp
		waveform/waveformrendermark.cpp
                waveform/waveformrendermarkrange.cpp
                waveform/waveformrenderbeat.cpp


                imginvert.cpp
                imgloader.cpp
                imgcolor.cpp

                trackinfoobject.cpp
                player.cpp
                playermanager.cpp
                sounddevice.cpp
                soundmanager.cpp
                sounddeviceportaudio.cpp
                dlgprefrecord.cpp
                recording/enginerecord.cpp
                recording/writeaudiofile.cpp
                playerinfo.cpp

                segmentation.cpp
                audiopath.cpp
                soundmanagerconfig.cpp
                """)

#Set up the library path on Windows:
if 'win' in platformString:
	env.Append(CPPPATH='#/../mixxx-win' + bitwidth + 'lib-msvc') #If you add more directories, separate them with a semicolon (;)
	env.Append(LIBPATH='#/../mixxx-win' + bitwidth + 'lib-msvc')
	env.Append(CPPPATH='../../lib/ladspa') #If you add more directories, separate them with a semicolon (;)
	env.Append(LINKFLAGS = ['/nodefaultlib:libc.lib', '/nodefaultlib:libcd.lib',  '/entry:mainCRTStartup'])
	env.Append(LIBS='advapi32') # needed for PortMIDI
#'/subsystem:windows',

if platformString == 'bsd':
	env.Append(CPPPATH=['/usr/include', '/usr/local/include', '/usr/X11R6/include/'])
	env.Append(LIBPATH=['/usr/lib/', '/usr/local/lib', '/usr/X11R6/lib'])
#BSD hacks
#XXX todo: move these into their proper places

	env.Append(LIBS='pthread')
	env.Append(LIBS=['ogg', 'vorbis']) #why do we need to do this on OpenBSD and not on Linux? if we don't then CheckLib("vorbisfile") fails
elif platformString == 'osx':
	#Non-standard libpaths for fink and certain (most?) darwin ports
	env.Append(LIBPATH = ['/sw/lib'])
	env.Append(CPPPATH = ['/sw/include'])

	#Non-standard libpaths for darwin ports
	env.Append(LIBPATH = ['/opt/local/lib'])
	env.Append(CPPPATH = ['/opt/local/include'])


#Check for dependencies if we're not doing a clean...
#if not env.GetOption('clean') and not SCons.Util.containsAny(os.sys.argv, ['-h', '--help']):
conf = Configure(env, custom_tests = { 'CheckForPKGConfig' : CheckForPKGConfig, 'CheckForPKG' : CheckForPKG })

#TODO: Add all of the other configure checks as custom_tests properly.

# On Posix default SCons.LIBPREFIX = 'lib', on Windows default SCons.LIBPREFIX = ''

#XXX all these Exit(1) calls should be turned into a list of libs to look for and then a loop that does the exit if any(conf.CheckLib(lib) for lib in list)
if not conf.CheckLib('portaudio'):
	print 'Did not find libportaudio.a, portaudio.lib, or the PortAudio-v19 development header files - exiting!'
	Exit(1)

if not conf.CheckLib(['id3tag','libid3tag-release']):
	print 'Did not find libid3tag.a, libid3tag.lib, or the libid3tag development header files - exiting!'
	Exit(1)

if not conf.CheckLib(['mad','libmad']):
	print 'Did not find libmad.a, libmad.lib, or the libmad development header files - exiting!'
	Exit(1)

#Check for libsndfile
#if not conf.CheckLibWithHeader(['sndfile', 'libsndfile'], 'sndfile.h', 'C'):
if not conf.CheckLib(['sndfile', 'libsndfile']):
	print "Did not find libsndfile or it\'s development headers, exiting!"
	Exit(1)
else:
	#env.Append(LIBS='sndfile') #XXX is this necessary?
	env.Append(CPPDEFINES = '__SNDFILE__')
	sources.append('soundsourcesndfile.cpp') ## TODO: Convert this to a SharedLibrary, so it can be installed without having to run scons twice after a clean


#Check for Ogg and Vorbis
if platformString == 'windows' and bitwidth == '64':
	if not conf.CheckLib('vorbisfile_static'): # For some reason this has to be checked this way on win64, otherwise it looks for the dll lib which will cause a conflict later (at line 713)
		print 'Did not find vorbisfile_static.lib or the libvorbisfile development headers, exiting!'
		Exit(1)
else:
	if not conf.CheckLib('vorbisfile'):
		print 'Did not find libvorbisfile.a, libvorbisfile.lib, or the libvorbisfile development headers, exiting!'
		Exit(1)

if not conf.CheckLib('vorbis'):
	print 'Did not find libvorbis.a, libvorbis.lib, or the libvorbisfile development headers, exiting!'
	Exit(1)

if not conf.CheckLib('ogg'):
	print 'Did not find libogg.a, libogg.lib, or the libogg development headers, exiting!'
	Exit(1)


## Check for OpenGL (it's messy to do it for all three platforms)
## XXX this should *NOT* have hardcoded paths like this
if not conf.CheckLib('GL') and not conf.CheckCHeader('GL/gl.h') and not conf.CheckLib('opengl32') and not conf.CheckCHeader('/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers/gl.h'):
	print 'Did not find OpenGL development files, exiting!'
	Exit(1)

if not conf.CheckLib('GLU') and not conf.CheckCHeader('GL/glu.h') and not conf.CheckLib('glu32') and not conf.CheckCHeader('/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers/glu.h'):
	print 'Did not find GLU development files, exiting!'
	Exit(1)

#Check if FFMPEG was enabled
CheckFFMPEG(conf, sources)

#Check for PortTime
if not conf.CheckLib(['porttime', 'libporttime']) and not conf.CheckHeader(['porttime.h']):
	print "Did not find PortTime or its development headers, exiting!"
	Exit(1)

#Check for PortMIDI & PortTime
if not conf.CheckLib(['portmidi', 'libportmidi']) and not conf.CheckHeader(['portmidi.h']):
 	print "Did not find PortMidi or its development headers, exiting!"
 	Exit(1)


sources += Split("""midi/mididevice.cpp """);
sources += Split("""midi/mididevicemanager.cpp """);
sources += Split("""midi/midideviceportmidi.cpp """);

#Platform-specific checks for Linux...
if platformString == 'linux':
	#Check for g++ (yeah, SCONS is a bit dumb here)
	if os.system("which g++ > /dev/null"): #Checks for non-zero return code
		print "Did not find g++, exiting!"
		Exit(1)

	#Check for pkg-config
	if not conf.CheckForPKGConfig('0.15.0'):
		print 'pkg-config >= 0.15.0 not found.'
		Exit(1)

	#Check for QT >= 4.3
	if not conf.CheckForPKG('QtCore', '4.3'):
		print 'QT >= 4.3 not found.'
		Exit(1)
	else:
		#Grabs the QT4 include paths
		"""
		env.ParseConfig('pkg-config QtCore --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config Qt3Support --silence-errors --cflags') #QT3 support breaks the build
		env.ParseConfig('pkg-config QtSql --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtGui --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtXml --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtOpenGL --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtScript --silence-errors --cflags --libs')
		"""
		#Try using David's qt4.py's Qt4-module finding thingy instead of pkg-config.
		#(This hopefully respects our qtdir=blah flag while linking now.)

		env.EnableQt4Modules([
		'QtCore',
		'QtGui',
		'QtOpenGL',
		'Qt3Support',
		'QtXml',
		'QtSvg',
		'QtSql',
		'QtScript',
		'QtXmlPatterns',
		'QtWebKit'
		#'QtUiTools',
		#'QtDesigner',
		#'QtWebKit',
		],
		debug=False,
		)

	#Another check for PortAudio-v19 # why? -kousu
	env.ParseConfig('pkg-config --cflags --libs portaudio-2.0')
		#If the above line looks like magic, it's because it really is. (Read about ParseConfig, it's nifty)

#Platform-specific checks for OS X
if platformString == 'osx':

	env.Append(CPPPATH='/Library/Frameworks/OpenGL.framework/Headers/')
	env.Append(LINKFLAGS='-framework OpenGL')

	#QT4
	env.Append(LINKFLAGS = '-framework QtCore -framework QtOpenGL -framework Qt3Support -framework QtGui -framework QtSql -framework QtXml -framework QtXmlPatterns  -framework QtNetwork -framework QtSql -framework QtScript -framework QtWebKit')
	env.Append(CPPPATH = ['/Library/Frameworks/QtCore.framework/Headers/',
				'/Library/Frameworks/QtOpenGL.framework/Headers/',
				'/Library/Frameworks/Qt3Support.framework/Headers/',
				'/Library/Frameworks/QtGui.framework/Headers/',
				'/Library/Frameworks/QtXml.framework/Headers/',
				'/Library/Frameworks/QtNetwork.framework/Headers/',
				'/Library/Frameworks/QtSql.framework/Headers/',
				'/Library/Frameworks/QtWebKit.framework/Headers/',
				'/Library/Frameworks/QtScript.framework/Headers/'])

	#Non-standard libpaths for fink and darwin ports
	env.Append(LIBPATH = ['/sw/lib'])
	env.Append(CPPPATH = ['/sw/include'])

	#Check for CoreMIDI
	if not conf.CheckCXXHeader('/System/Library/Frameworks/CoreMIDI.framework/Headers/CoreMIDI.h'):
		print 'Did not find CoreMIDI framework, exiting! (Please install it)'
		Exit(1)
	else:
		env.Append(LINKFLAGS = '-framework CoreMIDI -framework CoreFoundation -framework CoreAudio -framework Carbon -framework QuickTime -framework AudioToolbox -framework AudioUnit') #Have to add the rest of these frameworks somewhere..


#hack: check for these here, before conf.Finish happens
have_mp4v2_h = conf.CheckHeader('mp4v2/mp4v2.h')
have_mp4 = (have_mp4v2_h and conf.CheckLib(['mp4v2', 'libmp4v2'])) or conf.CheckLib('mp4')

# We have to check for libfaad version 2.6 or 2.7. In libfaad
# version 2.7, the type for the samplerate is unsigned long*,
# while in 2.6 the type is uint32_t*. We can use the optional
# call parameter to CheckLibWithHeader to build a test file to
# check which one this faad.h supports.

have_faad = conf.CheckLib(['faad', 'libfaad'])
have_faad_26 = False

# Check for libfaad version 2.6. This check doesn't work correctly on Windows
# And we build it manually anyway, so we know it's v2.7
if have_faad and 'win' not in platformString:
	have_faad_26 = (not conf.CheckLibWithHeader(
                        'libfaad', 'faad.h', 'c++',
                        call = 'faacDecInit2(0, 0, 0, (unsigned long*)0, (unsigned char*)0);',
                        autoadd=False))

have_m4a = have_mp4 and have_faad
flags['m4a'] = getFlags(env, 'm4a', 0)
if int(flags['m4a']) and not have_m4a:
        if not have_mp4:
                print 'Did not find libmp4v2 or the libmp4v2 development headers, exiting!'
        if not have_faad:
                print 'Did not find libfaad or the libfaad development headers, exiting!'
        Exit(1)


env = conf.Finish()

#Declare the flags for Mixxx's config/track listing files:
#The quotes are necessary, since these are used directly in C code as strings
if platformString in ('linux', 'bsd'):
        _mixxx_files = [('SETTINGS_PATH','.mixxx/'), ('BPMSCHEME_FILE','mixxxbpmscheme.xml'), ('SETTINGS_FILE', 'mixxx.cfg'), ('TRACK_FILE', 'mixxxtrack.xml')]
elif platformString == 'osx': #right now this is the same as linux and bsd, but these files should really go in ~/Library/Applicationsomething like the rest of OS X apps do
        _mixxx_files = [('SETTINGS_PATH','.mixxx/'), ('BPMSCHEME_FILE', 'mixxxbpmscheme.xml'), ('SETTINGS_FILE', 'mixxx.cfg'), ('TRACK_FILE', 'mixxxtrack.xml')]
elif 'win' in platformString:
        _mixxx_files = [('SETTINGS_PATH','Local Settings/Application Data/Mixxx/'), ('BPMSCHEME_FILE', 'mixxxbpmscheme.xml'), ('SETTINGS_FILE', 'mixxx.cfg'), ('TRACK_FILE', 'mixxxtrack.xml')]
_mixxx_files = [(k, r'\"' + v + r'\"') for k,v in _mixxx_files] #escape the filepaths, so that they wind up as C-strings to the C-compiler (the \s are so the shell doesn't eat the ")
env.Append(CPPDEFINES=_mixxx_files)
del _mixxx_files #safety net

# say where to find resources on Unix
# XXX we should replace this with a RESOURCES_PATH and covers Win and OS X too
if platformString in ('linux', 'bsd'):
	env.Append(CPPDEFINES=('UNIX_SHARE_PATH', r'\"' + os.path.join(ARGUMENTS.get('prefix', '/usr/local'),'share/mixxx') + r'\"'))

#declare platform specific flags? though we shouldn't really need these, the compilers should Just Know...
#on __APPLE__ it works like that. probably we just need to look into what the default __platform__ #defines are and search and replace in the code
env.Append(CPPDEFINES=machine)

if platformString == 'linux':
	env.Append(CPPDEFINES='__LINUX__')
elif platformString == 'bsd':
	env.Append(CPPDEFINES='__BSD__')
elif 'win' in platformString:
	env.Append(CPPDEFINES='__WINDOWS__')
	env.Append(CPPDEFINES='UNICODE')	# Need this on Windows until we have UTF16 support in Mixxx
	env.Append(CPPDEFINES='WIN'+bitwidth)

if platformString in ('linux', 'bsd'): #a define for code that works on unix only can ask for (not sure if this is actually used anywhere)
	env.Append(CPPDEFINES='__UNIX__')

env.Append(CPPDEFINES = '__PORTAUDIO__'); #Turn on PortAudio support in Mixxx
env.Append(CPPPATH = ['.', '../', '../../']) #Fun fun fun with paths


if platformString in ('linux', 'bsd'):
	env.Append(LIBS = 'Qt3Support')
	env.Append(LIBS = 'QtXml')
	env.Append(LIBS = 'QtGui')
	env.Append(LIBS = 'QtCore')
	env.Append(LIBS = 'QtNetwork')
	env.Append(LIBS = 'QtOpenGL')
	env.Append(LIBS = 'QtWebKit')
	env.Append(LIBS = 'QtScript')
	env.Append(LIBS = 'sndfile') #? we shouldn't have to do this...
	env.Append(LIBS = 'vorbisfile') #? we shouldn't have to do this...

if 'win' in platformString:
	env.Append(LIBS = 'Qt3Support4'); #Windows needs this instead of 'Qt3Support'
	env.Append(LIBS = 'QtXml4');
	env.Append(LIBS = 'QtXmlPatterns4');
	env.Append(LIBS = 'QtSql4');
	env.Append(LIBS = 'QtGui4');
	env.Append(LIBS = 'QtCore4');
	env.Append(LIBS = 'QtWebKit4');
	env.Append(LIBS = 'QtOpenGL4');
	env.Append(LIBS = 'WinMM'); #Needed for Midi stuff
	env.Append(LIBS = 'ogg_static')
	env.Append(LIBS = 'vorbis_static')
	env.Append(LIBS = 'vorbisfile_static')
	env.Append(LIBS = 'imm32')
	env.Append(LIBS = 'wsock32')
	env.Append(LIBS = 'delayimp')
	env.Append(LIBS = 'winspool')
	env.Append(LIBS = 'shell32')

env.Append(CPPDEFINES = ['QT3_SUPPORT', 'QT3_SUPPORT_WARNINGS', 'QT_THREAD_SUPPORT', 'QT_SHARED', 'QT_TABLET_SUPPORT']) #Stolen from Mixxx's build output

if platformString in ('linux','bsd') or 'win' in platformString:
	env.Append(CPPPATH=['$QTDIR/include/Qt3Support',
			    '$QTDIR/include/QtCore',
			    '$QTDIR/include/QtGui',
			    '$QTDIR/include/QtXml',
			    '$QTDIR/include/QtNetwork',
			    '$QTDIR/include/QtSql',
			    '$QTDIR/include/QtOpenGL',
			    '$QTDIR/include/QtWebKit',
			    '$QTDIR/include/Qt'])

if 'win' in platformString:
	env.Append(CPPPATH=["$VCINSTALLDIR/include/atl", "C:/Program Files/Microsoft Platform SDK/Include/atl"])
	env.Append(CPPDEFINES = 'WIN'+bitwidth) #for soundtouch
else:
	env.Append(CCFLAGS = Split(""" -pipe -Wall -W -g """)) # omghax
	env.Append(LINKFLAGS = Split(""" -pipe -Wall -W -g"""))
	if platformString != 'osx':
		env.Append(LINKFLAGS = "-Wl,-rpath,$QTDIR/lib")
	env.Append(LINKFLAGS = "-Wl,-rpath,$QTDIR/lib")
	env.Append(CPPDEFINES = "_REENTRANT")

#Uic these guys (they're moc'd automatically after this) - Generates the code for the QT UI forms
env.Uic4('dlgpreferencesdlg.ui')
env.Uic4('dlgprefsounddlg.ui')
env.Uic4('dlgprefsounditem.ui')
env.Uic4('dlgprefmidibindingsdlg.ui')
env.Uic4('dlgprefplaylistdlg.ui')
env.Uic4('dlgprefnomididlg.ui')
env.Uic4('dlgprefcontrolsdlg.ui')
env.Uic4('dlgprefeqdlg.ui')
env.Uic4('dlgprefcrossfaderdlg.ui')
env.Uic4('dlgprefbpmdlg.ui')
env.Uic4('dlgbpmschemedlg.ui')
# env.Uic4('dlgbpmtapdlg.ui')
env.Uic4('dlgprefvinyldlg.ui')
env.Uic4('dlgprefrecorddlg.ui')
env.Uic4('dlgaboutdlg.ui')
env.Uic4('dlgmidilearning.ui')
env.Uic4('dlgtrackinfo.ui')
env.Uic4('dlgprepare.ui')
env.Uic4('dlgautodj.ui')

#Add the QRC file which compiles in some extra resources (prefs icons, etc.)
env.Qrc('#res/mixxx.qrc')
sources += Split(""" #res/qrc_mixxx.cc """)

if 'win' in platformString:
	env.RES('mixxx.rc')
	sources += Split(""" mixxx.res """)

#Tell SCons to build libraries that are bundled with Mixxx
#===================================================

#SoundTouch
#XXX this should be done with a subsconscript

soundtouch_path = 'soundtouch-1.4.1'

env.Append(CPPPATH=['#lib/'+soundtouch_path])
sources += Split("""engine/enginebufferscalest.cpp
                    #lib/""" + soundtouch_path + """/SoundTouch.cpp
                    #lib/""" + soundtouch_path + """/TDStretch.cpp
                    #lib/""" + soundtouch_path + """/RateTransposer.cpp
                    #lib/""" + soundtouch_path + """/AAFilter.cpp
                    #lib/""" + soundtouch_path + """/FIFOSampleBuffer.cpp
                    #lib/""" + soundtouch_path + """/FIRFilter.cpp
                    #lib/""" + soundtouch_path + """/PeakFinder.cpp
                    #lib/""" + soundtouch_path + """/BPMDetect.cpp
                    """)

if 'win' in platformString:
	if bitwidth == '64':
		sources += Split("""#lib/""" + soundtouch_path + """/cpu_detect_x64_win.cpp""")
	else:
		sources += Split("""#lib/""" + soundtouch_path + """/cpu_detect_x86_win.cpp""")
else:
	if bitwidth == '64':
		sources += Split("""#lib/""" + soundtouch_path + """/cpu_detect_x64_gcc.cpp""")
	else:
		sources += Split("""#lib/""" + soundtouch_path + """/cpu_detect_x86_gcc.cpp""")


#KissFFT
env.Append(CPPPATH=['#lib/kissfft'])
sources += Split("""#lib/kissfft/kiss_fft.c""")

#libsamplerate - Getting rid of this out of our source tree since we don't use it.
#env.Append(CPPPATH='#lib/libsamplerate')
#sources += Split("""engine/enginebufferscalesrc.cpp #lib/libsamplerate/samplerate.c #lib/libsamplerate/src_linear.c #lib/libsamplerate/src_sinc.c #lib/libsamplerate/src_zoh.c""")

#fidlib (for EQs)
#XXX this should be a SharedLib() line
env.Append(CPPPATH='#lib/fidlib-0.9.9/')
sources += Split("""#lib/fidlib-0.9.9/fidlib.c """)

## Platform-specific compile/link flags needed for fidlib
if 'win' in platformString:
	env.Append(CPPDEFINES = 'T_MSVC')
	#env.Append(CXXFLAGS = '-DT_MSVC') #is this still needed?
	env.Append(LINKFLAGS = ['/nodefaultlib:LIBCMT.lib', '/nodefaultlib:LIBCMTD.lib'])
	env.Append(CXXFLAGS = '/Zc:wchar_t-') #Ugh, MSVC-only hack :( see http://www.qtforum.org/article/17883/problem-using-qstring-fromstdwstring.html
else:
	env.Append(CPPDEFINES = 'T_LINUX') #so maybe "T_LINUX" isn't really accurate for an else case, but the only platforms really in existence are Unix and Win right now, and that's all we're targetting


#Parse command-line build flags
build_flags = ""

print "\nFeatures Summary:\n================"


#High quality EQs
flags['hifieq'] = getFlags(env, 'hifieq', 1)
if int(flags['hifieq']) == 0:
	env.Append(CPPDEFINES = ['__LOFI__', '__NO_INTTYPES__']) #Enables old crappy EQs
	print "High quality EQs... disabled"
else:
	print "High quality EQs... enabled"
	build_flags += 'hifieq '

#Experimental IPOD support
flags['ipod'] = getFlags(env, 'ipod', 0)
if int(flags['ipod']):
	env.Append(CPPDEFINES = '__IPOD__')

	if 'win' in platformString:
		env.Append(LIBS = 'gpod');
		# You must check v-this-v directory out from http://publicsvn.songbirdnest.com/vendor-binaries/trunk/windows-i686-msvc8/libgpod/
		env.Append(LIBPATH='../../../windows-i686-msvc8/libgpod/release/lib')
		# Following building the following must be added to the dist folder in order for mixxx to run with ipod support on Windows
		# \windows-i686-msvc8\libgpod\release\lib\libgpod.dll
		# \windows-i686-msvc8\glib\release\bin\libgobject-2.0-0.dll
		# \windows-i686-msvc8\glib\release\bin\libglib-2.0-0.dll
		# \windows-i686-msvc8\libiconv\release\bin\iconv.dll
		# \windows-i686-msvc8\gettext\release\binintl.dll
	if platformString == 'linux' or platformString == 'osx':
		# env.Append(LIBS = 'libgpod-1.0')
		# env.Append(LIBS = 'glib-2.0')
		env.ParseConfig('pkg-config libgpod-1.0 --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config glib-2.0 --silence-errors --cflags --libs')

	sources += Split("""wipodtracksmodel.cpp """) #IPOD
	print "iPod support... enabled"
	build_flags += 'ipod '
else:
	print "iPod support... disabled"

#Experimental Shoutcast
flags['shoutcast'] = getFlags(env, 'shoutcast', 0)

if int(flags['shoutcast']):
	shoutmp3 = 0
	shoutogg = 0

	conf = Configure(env, custom_tests = { 'CheckForPKGConfig' : CheckForPKGConfig, 'CheckForPKG' : CheckForPKG })
	if not conf.CheckLib('shout'):
		print "libshout was not found! Please install it or compile Mixxx without Shoutcast support using the shoutcast=0 flag."
		Exit(1)

	env.Append(CPPDEFINES = '__SHOUTCAST__')

	sources += Split(""" dlgprefshoutcast.cpp engine/engineshoutcast.cpp encoder.cpp """ )
	build_flags += 'shoutcast '


	if conf.CheckLibWithHeader('mp3lame', 'lame/lame.h', 'C'):
		env.Append(CPPDEFINES = '__SHOUTCAST_LAME__')
		sources += Split(""" encodermp3.cpp """)
		shoutmp3 = 1

	if conf.CheckLib('vorbisenc'):
		env.Append(CPPDEFINES = '__SHOUTCAST_VORBIS__')
		sources += Split("""  encodervorbis.cpp """)
		shoutogg = 1


	if shoutmp3 and shoutogg:
		print "Shoutcast support (OGG/MP3)... enabled"
	elif shoutmp3:
		print "Shoutcast support (MP3)... enabled"
	elif shoutogg:
		print "Shoutcast support (OGG)... enabled"
	else:
		print "Shoutcast support... enabled"

	env.Uic4('dlgprefshoutcastdlg.ui')

else:
	print "Shoutcast support... disabled"

#LADSPA
flags['ladspa'] = getFlags(env, 'ladspa', 0)
if int(flags['ladspa']):
	env.Append(CPPPATH=['#lib/ladspa']) #If you add more directories, separate them with a semicolon (;)
	env.Append(CPPDEFINES = '__LADSPA__')
	sources += Split("""engine/engineladspa.cpp
                            ladspa/ladspaloader.cpp
                            ladspa/ladspalibrary.cpp
                            ladspa/ladspaplugin.cpp
                            ladspa/ladspainstance.cpp
                            ladspa/ladspacontrol.cpp
                            ladspa/ladspainstancestereo.cpp
                            ladspa/ladspainstancemono.cpp
                            ladspaview.cpp
                            ladspa/ladspapreset.cpp
                            ladspa/ladspapresetmanager.cpp
                            ladspa/ladspapresetknob.cpp
                            ladspa/ladspapresetinstance.cpp
                            dlgladspa.cpp
                            ladspa/ladspapresetslot.cpp
                            """)
	plugins += SConscript(File('#lib/ladspa/SConscript'))
	env.Alias('plugins', plugins)
	print "LADSPA support... enabled"
	build_flags += 'ladspa '
else:
	print "LADSPA support... disabled"

#Vinyl Control
flags['vinylcontrol'] = getFlags(env, 'vinylcontrol', 1)
if int(flags['vinylcontrol']):
	env.Append(CPPDEFINES = '__VINYLCONTROL__')
	sources += Split(""" vinylcontrol.cpp vinylcontrolproxy.cpp vinylcontrolscratchlib.cpp vinylcontrolxwax.cpp dlgprefvinyl.cpp vinylcontrolsignalwidget.cpp engine/enginevinylcontrol.cpp """)
	env.Append(CPPPATH='#lib/xwax')
	if 'win' in platformString:
		sources += Split("""#lib/xwax/timecoder_win32.c """)
	else:
		sources += Split("""#lib/xwax/timecoder.c """)
	env.Append(CPPPATH='#lib/scratchlib')
	sources += Split("""#lib/scratchlib/DAnalyse.cpp """)
	print "Vinyl Control... enabled"
	build_flags += 'vinylcontrol '
else:
	print "Vinyl Control... disabled"

flags['msvcdebug'] = getFlags(env, 'msvcdebug', 0)
if 'win' in platformString:
	if int(flags['msvcdebug']):
		env.Append(CCFLAGS = '/MDd') # required for sndfile w/ flac support on windows
		env.Append(LINKFLAGS = '/DEBUG')
		if bitwidth == '64':
			env.Append(CXXFLAGS = '/Zi')
			env.Append(LINKFLAGS = '/NODEFAULTLIB:MSVCRT')
		else:
			env.Append(CXXFLAGS = '/ZI')
		print "MSVC Debugging... enabled"
		build_flags += 'msvcdebug '
	else:
		env.Append(LINKFLAGS = '/subsystem:windows')
		env.Append(CCFLAGS = '/MD') # required for sndfile w/ flac support on windows
		print "MSVC Debugging... disabled"


flags['tonal'] = getFlags(env, 'tonal', 0)
if int(flags['tonal']):
	print "Tonal analysis... enabled"
	build_flags += 'tonal '
	sources += Split("""tonal/FourierTransform.cxx tonal/Segmentation.cxx
			tonal/tonalanalyser.cpp tonal/ConstantQTransform.cxx
			tonal/ConstantQFolder.cxx""")
else:
	print "Tonal analysis... disabled"



flags['m4a'] = getFlags(env, 'm4a', 0)
if int(flags['m4a']):
	print "Apple M4A audio file support...",
	if have_m4a:
		print "enabled"

		# If the compile did not work, then enable the M4AHACK define.
		if have_faad_26:
			env.Append(CPPDEFINES = '__M4AHACK__')
			print "libfaad 2.6 compatibility mode... enabled"

		if have_mp4v2_h:
			env.Append(CPPDEFINES = '__MP4V2__')

	#	env.ParseConfig('pkg-config libmp4v2-dev --silence-errors --cflags --libs') # no pkg-config data for libmp4v2-dev
	#	FIXME: should do conf.CheckCHeader('mp4.h') or something...
		env.Append(CPPDEFINES = '__M4A__')
		build_flags += 'm4a '
		env.Append(LIBS = 'libmp4v2')
		env.Append(LIBS = 'libfaad')
	else:
		print "not found (did you install libmp4v2 and libfaad?)"
else:
	print "Apple M4A audio file support... disabled"



def build_gtest():
	gtest_dir = env.Dir("#lib/gtest-1.3.0")
	gtest_dir.addRepository(env.Dir('#lib/gtest-1.3.0'))
	#env['EXE_OUTPUT'] = '#/lib/gtest-1.3.0/bin'  # example, optional
	env['LIB_OUTPUT'] = '#/lib/gtest-1.3.0/lib'
	Export('env')
	env.SConscript(env.File('scons/SConscript', gtest_dir))

	env.Append(LIBPATH="#lib/gtest-1.3.0/lib")
	env.Append(LIBS = 'gtest')
	env.Append(CPPPATH="#lib/gtest-1.3.0/include")

def build_tests():
	test_sources = (Glob('test/*.cpp', strings=True) + [x for x in sources if x != "main.cpp"])
	env.Program(target='mixxx-test', source=test_sources)
	Command("../mixxx-test", "./mixxx-test", Copy("$TARGET", "$SOURCE"))

def run_tests():
	ret = Execute("./mixxx-test")
	if ret != 0:
		print "WARNING: Not all tests pass. See mixxx-test output."
		Exit(ret)

flags['test'] = getFlags(env, 'test', 0) or 'test' in BUILD_TARGETS

if int(flags['test']):
	print "Test suite... enabled"
	build_gtest()
	build_flags += 'test '
else:
	print "Test suite... disabled"

# Script Studio
flags['script'] = getFlags(env, 'script', 0)
if int(flags['script']):
	if 'win' in platformString:
		env.Append(LIBS = 'QtScript4')
	elif platformString == 'linux':
		env.Append(LIBS = 'QtScript')
	elif platformString == 'osx':
		#XXX put in logic here to add a -framework QtScript
		#env.Append(
		pass
	print "MixxxScript Studio... enabled"

	build_flags += 'script '
	sources += Split("""script/scriptengine.cpp script/scriptcontrolqueue.cpp
			script/scriptstudio.cpp script/scriptrecorder.cpp
			script/playinterface.cpp script/macro.cpp
			script/scriptcontrolevent.cpp script/trackcontrolevent.cpp
			script/numbercontrolevent.cpp script/numberrecorder.cpp
			script/macrolist.cpp script/trackrecorder.cpp
			script/sdatetime.cpp script/signalrecorder.cpp
			script/macrolistitem.cpp script/qtscriptinterface.cpp""")
	env.Append(CPPPATH = '$QTDIR/include/QtScript')
	env.Append(CPPDEFINES = '__SCRIPT__')

	env.Uic4('script/scriptstudio.ui')
else:
	flags['script'] = 0
	print "MixxxScript Studio... disabled"

# MIDI Scripting
flags['midiscript'] = getFlags(env, 'midiscript', 0)
if int(flags['midiscript']):
	if 'win' in platformString:
		env.Append(LIBS = 'QtScript4')
	elif platformString == 'linux':
		env.Append(LIBS = 'QtScript')
	elif platformString == 'osx':
		#XXX put in logic here to add a -framework QtScript
		#env.Append(
		pass
	print "MIDI Scripting... enabled"

	build_flags += 'midiscript '
	sources += Split("""midi/midiscriptengine.cpp""")
	env.Append(CPPPATH = '$QTDIR/include/QtScript')
	env.Append(CPPDEFINES = '__MIDISCRIPT__')
else:
	flags['midiscript'] = 0
	print "MIDI Scripting... disabled"

# Profiling and Optimization
if platformString == 'linux':
	flags['profiling'] = getFlags(env, 'profiling', 0)
	if int(flags['profiling']):
		env.Append(CCFLAGS = '-pg')
		env.Append(LINKFLAGS = '-pg')
		print "gprof (Linux) profiling support... enabled"
		build_flags += 'profiling '
	else:
		print "gprof (Linux) profiling support... disabled"

if platformString == 'osx':
	flags['profiling'] = getFlags(env, 'profiling', 0)
	if int(flags['profiling']):
		env.Append(CCFLAGS = '-finstrument-functions')
		env.Append(LINKFLAGS = '-lSaturn')
		print "Saturn (OS X) profiling support... enabled"
		build_flags += 'profiling '
	else:
		print "profiling profiling support... disabled"

flags['tuned'] = getFlags(env, 'tuned', 0)
if int(flags['tuned']):
	if not 'win' in platformString:
		ccv = env['CCVERSION'].split('.')
		if int(ccv[0]) >= 4 and int(ccv[1]) >= 2:
			env.Append(CCFLAGS = '-march=native')
			env.Append(LINKFLAGS = '-march=native')
			print "Optimizing for this CPU... yes"
			build_flags += 'tuned '
		else:
			print "Optimizing for this CPU... no (requires gcc >= 4.2.0)"
	else:
		if bitwidth == '64':
			print "Optimizing for this CPU class (" + machine + ")... yes"
			env.Append(CXXFLAGS = '/favor:' + machine)
		else:
			print "Optimizing for this CPU... no (not supported on 32-bit MSVC)"
else:
	if bitwidth == '64':
		if 'makerelease' in COMMAND_LINE_TARGETS:
			print "Optimizing for this CPU class... no  (due to makerelease)"
			# AMD64 is for AMD CPUs, EM64T is for Intel x64 ones (as opposed to IA64 which uses a different compiler.)
			# For a release, we choose to have code run about the same on both
			env.Append(CXXFLAGS = '/favor:blend')

#Specific optimization
flags['optimize'] = getFlags(env, 'optimize', 1)
if int(flags['optimize']):
	if 'win' in platformString:
		if machine == 'AMD64' or machine == 'EM64T':
			env.Append(LINKFLAGS = '/MACHINE:X64')
		else:
			env.Append(LINKFLAGS = '/MACHINE:'+machine)
		if int(flags['msvcdebug']):
			print "Specific optimizations... DISABLED DUE TO DEBUG"
		else:
			print "Specific optimizations... enabled"
			build_flags += 'optimize=' + str(flags['optimize']) + ' '
			env.Append(CXXFLAGS = '/GL /MP')
			env.Append(LINKFLAGS = '/LTCG:STATUS')
			if flags['optimize']=='1':
				print "  Maximize speed (/O2)"
				env.Append(CXXFLAGS = '/O2')
			elif flags['optimize'] >= '2':
				print "  Maximum optimizations (/Ox)"
				env.Append(CXXFLAGS = '/Ox')
			if not machine == 'AMD64' and not machine == 'EM64T': # SSE and SSE2 are core instructions on x64
				if flags['optimize'] == '3':
					print "  SSE instructions enabled"
					env.Append(CXXFLAGS = '/arch:SSE')
				elif flags['optimize'] == '4':
					print "  SSE2 instructions enabled"
					env.Append(CXXFLAGS = '/arch:SSE2')
	else:
		if not int(flags['tuned']):
			print "Specific optimizations... enabled"
			build_flags += 'optimize=' + str(flags['optimize']) + ' '
			env.Replace(CFLAGS = '') # replace CFLAGS and CXXFLAGS with our own optimizations.
			if flags['optimize']=='1':
				env.Replace(CXXFLAGS = '-O3')
			elif flags['optimize']=='2':
				print "  P4 MMX/SSE optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=pentium4 -mmmx -msse2 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='3':
				print "  Intel Core Solo/Duo optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=prescott -mmmx -msse3 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='4':
				print "  Intel Core 2 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=nocona -mmmx -msse3 -mfpmath=sse -ffast-math -funroll-loops')
			elif flags['optimize']=='5':
				print "  Athlon Athlon-4/XP/MP optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=athlon-4 -mmmx -msse -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='6':
				print "  Athlon K8/Opteron/AMD64 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=k8 -mmmx -msse2 -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='7':
				print "  Athlon K8/Opteron/AMD64 + SSE3 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=k8-sse3 -mmmx -msse2 -msse3 -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='8':
				print "  Generic SSE/SSE2/SSE3 optimizations enabled (Celeron D)."
				env.Replace(CXXFLAGS = '-O3 -mmmx -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			env.Append(CXXFLAGS = ' ') # add a space to the end of CXXFLAGS
else:
	print "Specific optimizations... disabled"

#Linking with ASMLIB
flags['asmlib'] = getFlags(env, 'asmlib', 0)
if int(flags['asmlib']):
	print "Agner Fog\'s ASMLIB (http://www.agner.org/optimize)... enabled"
	env.Append(LIBPATH='#/../asmlib')
	build_flags += 'asmlib '
	if platformString == 'linux':
		env.Append(CXXFLAGS = '-fno-builtin')   #Use ASMLIB's functions instead of the compiler's
		env.Append(LIBS = '":alibelf' + bitwidth + 'o.a"')
	elif platformString == 'osx':
		env.Append(CXXFLAGS = '-fno-builtin')   #Use ASMLIB's functions instead of the compiler's
		env.Append(LIBS = '":alibmac' + bitwidth + 'o.a"')
	elif 'win' in platformString:
		env.Append(CXXFLAGS = '/Oi-')   #Use ASMLIB's functions instead of the compiler's
		env.Append(LIBS = 'alibcof' + bitwidth + 'o')
	env.Append(CXXFLAGS = ' ') # add a space to the end of CXXFLAGS
else:
	print "Agner Fog\'s ASMLIB (http://www.agner.org/optimize)... disabled"

# SoundTouch Optimizations -- turn them on only if we have SSE or MMX
# enabled. It's dumb that they appear here, but they make the most sense next to
# the optimization stuff. It's safe to assume that if opt > 1, then MMX and SSE
# are enabled. All 64-bit CPUs have MMX and SSE as well.
if bitwidth == '64' or (not 'win' in platformString and int(flags['optimize']) > 1) \
    or ('win' in platformString and int(flags['optimize']) > 2):
    sources += Split("""#lib/""" + soundtouch_path + """/mmx_optimized.cpp #lib/""" + soundtouch_path + """/sse_optimized.cpp""")
    env.Append(CPPDEFINES='ALLOW_X86_OPTIMIZATIONS')

# Enable SoundTouch 3DNow! optimizations for Windows (decides at runtime if they're useful)
if 'win' in platformString and not bitwidth == '64':
    sources += Split("""#lib/""" + soundtouch_path + """/3dnow_win.cpp""")

#Debugging output
flags['qdebug'] = getFlags(env, 'qdebug', 0)
if 'win' in platformString:
	if int(flags['msvcdebug']):
		flags['qdebug'] = 1		# Turn general debugging flag on too if msvcdebug is specified

if int(flags['qdebug']):
	build_flags += 'qdebug '
	print "Debugging message output... enabled"
else:
	env.Append(CPPDEFINES = 'QT_NO_DEBUG_OUTPUT')
	print "Debugging message output... disabled"

#Visual Studio 2005 hacks (MSVS Express Edition users shouldn't enable this)
flags['msvshacks'] = getFlags(env, 'msvshacks', 0)
if int(flags['msvshacks']):
	env.Append(CPPDEFINES = '__MSVS2005__')
	print "MSVS 2005 hacks... enabled"
	build_flags += 'msvshacks '
else:
	print "MSVS 2005 hacks... disabled"

#force 32-bit compile on GCC
'''flags['force32'] = getFlags(env, 'force32', 0)
if int(flags['force32']):
	env.Append(CCFLAGS = '-m32')
	env.Append(CXXFLAGS = '-m32')
	env.Append(LINKFLAGS = '-m32')
	print "Force 32-bit GCC compile... enabled"
else:
	print "Force 32-bit GCC compile... disabled"
'''

#Case Metrics
if 'win' in platformString or platformString == 'linux':
	flags['cmetrics'] = getFlags(env, 'cmetrics', 1)
else:
	flags['cmetrics'] = getFlags(env, 'cmetrics', 0) # Off on OS X for now...
if int(flags['cmetrics']):
	env.Append(CPPDEFINES = '__C_METRICS__')
	if 'win' in platformString:
		env.Append(LIBS = 'cmetrics')
	else:
		client = 'MIXXX'
		server = 'metrics.mixxx.org' # mixxx metrics collector
		Export('env platformString client server flags[\'force32\']')
		env.Append(CPPPATH='#lib/cmetrics')
		sources += SConscript('#lib/cmetrics/SConscript')
	print "Case Metrics profiling... enabled"
	build_flags += 'cmetrics '
else:
	print "Case Metrics profiling... disabled"

#env.Append(CPPDEFINES=[('BUILD_FLAGS', "'%s'" % build_flags)])

### Put flags info into a file
f = open("build.h","a")
try:
	f.write('#define BUILD_FLAGS "' + build_flags + '"\n')
finally:
	f.close()


#Tell SCons to build unit tests
if int(flags['test']):
	print "Building tests."
	build_tests()

if 'test' in BUILD_TARGETS:
	print "Running tests."
	run_tests()

#Set up the MSVC target to build a Visual Studio project/solution file
if 'msvc' in COMMAND_LINE_TARGETS:
	includes = map(str, Glob('#src/*.h'))
	includes += map(str, Glob('#src/visual/*.h'))
	#Make the project file aware of any command-line arguments that were passed...
	cmdargs = ""
	for k in SCons.Script.ARGUMENTS:
		cmdargs += " " + k + "=" + SCons.Script.ARGUMENTS[k]
	env.Append(MSVSSCONSFLAGS = cmdargs)
	#env.Append(MSVSSCONSFLAGS = ' qtdir=' + flags['qtdir'])

	# This is the right way to do it but scons is stupid and doesn't copy flags in... Adam
	# Set up environment for debug target
	# TODO Handle lib versions ie /MDd /Md etc...
	#debugenv = env.Clone()
	#debugenv.Prepend(LINKFLAGS = ['/DEBUG','/PDB:dist' + bitwidth + '/mixxx.pdb']) # Generate MS VC Program Debug Database
	#debugenv.Append(CXXFLAGS = '/ZI')

	msvc = env.MSVSProject(target = 'mixxx' + env['MSVSPROJECTSUFFIX'], srcs = sources, incs = includes, variant = 'Debug', runfile = '../dist' + bitwidth + '/mixxx.exe')

	# Reenable this once bug in scons is fixed...
	#msvc = env.MSVSProject(target = 'mixxx' + env['MSVSPROJECTSUFFIX'], srcs = sources, incs = includes, variant = 'Release', runfile = '../dist' + bitwidth + /mixxx.exe')

	env.Alias('msvc', msvc)

# Print the build flags (useful if the flags have been cached, ie. if you just run "scons"
# and want to see the flags that you used last time)
print "================"
print "Building with flags: " + build_flags
print "================\n"

#Save the options to cache
vars.Save(cachefile, env)

Export('env', 'sources', 'flags')
